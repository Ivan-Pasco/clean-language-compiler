// Basic tokens
WHITESPACE = _{ " " | "\r" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n" | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Keywords and identifiers
keyword = { ("return" | "if" | "else" | "iterate" | "in" | "to" | "step" | "test" | "error" | "function" | "functions" | "input" | "description" | "class" | "constructor" | "is" | "and" | "or" | "not" | "true" | "false" | "onError" | "constant" | "private" | "Array" | "Matrix" | "pairs" | "integer" | "float" | "boolean" | "string" | "void" | "any") ~ !ASCII_ALPHANUMERIC }
identifier = @{ !keyword ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
integer = @{ "-"? ~ ASCII_DIGIT+ }
float = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
number = _{ float | integer }
boolean = { "true" | "false" }

// Advanced size specifiers for types
size_specifier = { ":" ~ ASCII_DIGIT+ ~ ("u")? }

// String interpolation with {} syntax
string_content = @{ (!("\"" | "{" | "}") ~ ANY)+ }
string_interpolation = { "{" ~ (identifier ~ ("." ~ identifier)*) ~ "}" }
string_part = { string_content | string_interpolation }
string = { "\"" ~ string_part* ~ "\"" }

// Core types from specification
core_type = { 
    "boolean" |
    "integer" |
    "float" |
    "string" |
    "void" |
    "any"
}

// Advanced types with size specifiers
sized_type = { core_type ~ size_specifier }

// Composite types
matrix_type = { "Matrix" ~ "<" ~ type_ ~ ">" }
array_type = { "Array" ~ "<" ~ type_ ~ ">" }
pairs_type = { "pairs" ~ "<" ~ type_ ~ "," ~ type_ ~ ">" }

// Generic types
generic_type = { identifier ~ "<" ~ type_arguments ~ ">" }
type_parameter = @{ identifier }
type_parameters = { "<" ~ type_parameter ~ ("," ~ type_parameter)* ~ ">" }
type_arguments = { type_ ~ ("," ~ type_)* }

// Type definition
type_ = { 
    sized_type |
    core_type |
    matrix_type |
    array_type |
    pairs_type |
    generic_type |
    type_parameter |
    identifier
}

// Indentation-based blocks
INDENT = _{ "\t" }
NEWLINE = _{ "\n" | "\r\n" }
empty_line = _{ INDENT* ~ NEWLINE }
indented_block = { NEWLINE ~ (empty_line)* ~ INDENT+ ~ statement ~ (NEWLINE ~ (empty_line)* ~ INDENT+ ~ statement)* }

// Apply-blocks (core language feature) - Specification compliant
apply_block = { constant_apply_block | type_apply_block | method_apply_block | function_apply_block }

// Constant apply-blocks: constant: integer MAX_SIZE = 100 (most specific first)
constant_apply_block = { "constant" ~ ":" ~ indented_constant_assignments }
indented_constant_assignments = { NEWLINE ~ (empty_line)* ~ INDENT+ ~ constant_assignment ~ (NEWLINE ~ (empty_line)* ~ INDENT+ ~ constant_assignment)* }
constant_assignment = { type_ ~ identifier ~ "=" ~ expression }

// Type apply-blocks: integer: count = 0, maxSize = 100 (types before generic identifiers)
type_apply_block = { (core_type | sized_type | matrix_type | array_type | pairs_type) ~ ":" ~ indented_variable_assignments }
indented_variable_assignments = { NEWLINE ~ (empty_line)* ~ INDENT+ ~ variable_assignment ~ (NEWLINE ~ (empty_line)* ~ INDENT+ ~ variable_assignment)* }
variable_assignment = { identifier ~ "=" ~ expression }

// Method apply-blocks: array.push: item1, item2, item3 (object.method before generic identifiers)
method_apply_block = { method_call_chain ~ ":" ~ indented_expressions }
method_call_chain = { identifier ~ ("." ~ identifier)+ }

// Function apply-blocks: println: "Hello", "World" (catch-all for identifiers)
function_apply_block = { identifier ~ ":" ~ indented_expressions }
indented_expressions = { NEWLINE ~ (empty_line)* ~ INDENT+ ~ expression ~ (NEWLINE ~ (empty_line)* ~ INDENT+ ~ expression)* }

// Setup blocks for functions
description_block = { "description" ~ string }
input_type = { 
    sized_type |
    core_type |
    matrix_type |
    array_type |
    pairs_type |
    generic_type |
    type_parameter
}
input_declaration = { input_type ~ identifier }
input_block = { "input" ~ indented_input_block }
indented_input_block = { NEWLINE ~ (empty_line)* ~ INDENT+ ~ input_declaration ~ (NEWLINE ~ (empty_line)* ~ INDENT+ ~ input_declaration)* }
indented_block_with_declarations = { NEWLINE ~ INDENT+ ~ input_declaration ~ (NEWLINE ~ INDENT+ ~ input_declaration)* }

setup_block = { (description_block ~ NEWLINE ~ input_block) | (input_block ~ NEWLINE ~ description_block) | input_block | description_block }

// Object access and method calls
function_call = { identifier ~ type_arguments? ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }
method_call_base = { identifier | "(" ~ expression ~ ")" }
method_call_segment = { "." ~ identifier ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }
method_call = { method_call_base ~ method_call_segment+ }
property_access = { identifier ~ ("." ~ identifier)+ }
array_access = { identifier ~ "[" ~ expression ~ "]" }

// Primary expressions
primary = { 
    method_call |
    number |
    boolean |
    string |
    matrix_literal |
    array_literal |
    array_access |
    function_call |
    property_access |
    identifier |
    multiline_parenthesized_expr |
    "(" ~ expression ~ ")"
}

// Multi-line expressions within parentheses (allows newlines and indentation)
multiline_parenthesized_expr = { "(" ~ NEWLINE* ~ (INDENT* ~ multiline_expression)? ~ NEWLINE* ~ INDENT* ~ ")" }
multiline_expression = { primary ~ (NEWLINE* ~ INDENT* ~ operator ~ NEWLINE* ~ INDENT* ~ primary)* }

// Error handling with onError
on_error_expr = { base_expression ~ "onError" ~ base_expression }
on_error_block = { base_expression ~ "onError" ~ ":" ~ indented_block }

// Expression with operator precedence (updated per specification)
base_expression = { primary ~ (operator ~ primary)* }
expression = { on_error_block | on_error_expr | base_expression }

// Operators (removed matrix @ operators as they're now type-based)
operator = _{ binary_op | comparison_op }
binary_op = { "+" | "-" | "*" | "/" | "%" | "^" | "and" | "or" }
comparison_op = { "==" | "!=" | "<" | "<=" | ">" | ">=" | "is" | "not" }

// Arrays and Matrices
array_literal = { "[" ~ (expression ~ ("," ~ expression)*)? ~ "]" }
matrix_row = { "[" ~ (expression ~ ("," ~ expression)*)? ~ "]" }
matrix_literal = { "[" ~ matrix_row ~ ("," ~ matrix_row)* ~ "]" }

// Statements
statement = {
    return_stmt |
    error_stmt |
    on_error_block |
    if_stmt |
    iterate_stmt |
    range_iterate_stmt |
    test |
    variable_decl |
    apply_block |
    assignment |
    expression
}

// Type-first variable declarations (no let keyword)
variable_decl = { type_ ~ identifier ~ ("=" ~ expression)? }

// Assignment
assignment = { identifier ~ "=" ~ expression }

// Error statement (function call syntax)
error_stmt = { "error" ~ "(" ~ expression ~ ")" }

// Control flow with indentation
if_stmt = { "if" ~ expression ~ indented_block ~ ("else" ~ indented_block)? }

// Iteration
iterate_stmt = { "iterate" ~ identifier ~ "in" ~ expression ~ indented_block }
range_iterate_stmt = { "iterate" ~ identifier ~ "in" ~ expression ~ "to" ~ expression ~ ("step" ~ expression)? ~ indented_block }

// Test
test = { "test" ~ string ~ indented_block }

// Return
return_stmt = { "return" ~ expression? }

// Function declarations - Both standalone and functions block syntax supported

// Standalone function definition (Clean Language syntax: function ReturnType name())
standalone_function = { "function" ~ function_type? ~ identifier ~ "(" ~ parameter_list? ~ ")" ~ function_body }
parameter_list = { parameter ~ ("," ~ parameter)* }
parameter = { type_ ~ identifier }

// Functions block (the main supported syntax for function declarations)
functions_block = { "functions" ~ ":" ~ indented_functions_block }
indented_functions_block = { NEWLINE ~ INDENT+ ~ function_in_block ~ (NEWLINE ~ INDENT+ ~ function_in_block)* }
function_in_block = { function_type? ~ identifier ~ "(" ~ parameter_list? ~ ")" ~ function_body }
// Function body statements (similar to indented_block but without initial NEWLINE/INDENT)
function_statements = { statement ~ (NEWLINE ~ (empty_line)* ~ INDENT+ ~ statement)* }

function_body = { (NEWLINE ~ INDENT+ ~ setup_block ~ (empty_line)* ~ INDENT+ ~ function_statements) | (NEWLINE ~ INDENT+ ~ function_statements) }

// Function return type (excludes generic identifiers)
function_type = { 
    sized_type |
    core_type |
    matrix_type |
    array_type |
    pairs_type |
    generic_type |
    type_parameter
}

// Private blocks
private_block = { "private" ~ ":" ~ indented_functions_block }

// Class definition with "is" inheritance
class_field = { type_ ~ identifier }
class_body_item = { class_field | constructor | functions_block }
indented_class_body = { NEWLINE ~ (empty_line)* ~ INDENT+ ~ class_body_item ~ (NEWLINE ~ (empty_line)* ~ INDENT+ ~ class_body_item)* }

class_decl = { 
    "class" ~ identifier ~ 
    ("is" ~ generic_type)? ~ 
    indented_class_body?
}

constructor = { "constructor" ~ "(" ~ constructor_parameter_list? ~ ")" ~ indented_block? }
constructor_parameter_list = { constructor_parameter ~ ("," ~ constructor_parameter)* }
constructor_parameter = { (constructor_type ~ identifier) | identifier }
constructor_type = { 
    sized_type |
    core_type |
    matrix_type |
    array_type |
    pairs_type |
    generic_type
}

// Program with proper newline handling
program_item = { start_function | implicit_start_function | standalone_function | functions_block | class_decl | statement }
program = { SOI ~ NEWLINE* ~ (program_item ~ NEWLINE*)* ~ EOI }

start_function = { "function" ~ "start" ~ "(" ~ ")" ~ indented_block } 
implicit_start_function = { "start" ~ "(" ~ ")" ~ indented_block } 