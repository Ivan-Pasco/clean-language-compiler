// Basic tokens
WHITESPACE = _{ " " | "\r" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n" | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Keywords that should not be parsed as identifiers
keyword = { "return" | "if" | "else" | "iterate" | "in" | "to" | "step" | "test" | "print" | "println" | "error" | "function" | "functions" | "input" | "description" | "class" | "constructor" | "is" | "and" | "or" | "not" | "true" | "false" | "onError" | "constant" | "private" | "Array" | "Matrix" | "pairs" | "integer" | "float" | "boolean" | "string" | "void" }

// Identifiers and literals
identifier = @{ !keyword ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
integer = @{ "-"? ~ ASCII_DIGIT+ }
float = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
number = _{ float | integer }
boolean = { "true" | "false" }

// Advanced size specifiers for types
size_specifier = { ":" ~ ASCII_DIGIT+ ~ ("u")? }

// String interpolation with {} syntax
string_content = @{ (!("\"" | "{" | "}") ~ ANY)+ }
string_interpolation = { "{" ~ (identifier ~ ("." ~ identifier)*) ~ "}" }
string_part = { string_content | string_interpolation }
string = { "\"" ~ string_part* ~ "\"" }

// Core types from specification
core_type = { 
    "boolean" |
    "integer" |
    "float" |
    "string" |
    "void"
}

// Advanced types with size specifiers
sized_type = { core_type ~ size_specifier }

// Composite types
matrix_type = { "Matrix" ~ "<" ~ type_ ~ ">" }
array_type = { "Array" ~ "<" ~ type_ ~ ">" }
pairs_type = { "pairs" ~ "<" ~ type_ ~ "," ~ type_ ~ ">" }

// Generic types
generic_type = { identifier ~ "<" ~ type_arguments ~ ">" }
type_parameter = @{ identifier }
type_parameters = { "<" ~ type_parameter ~ ("," ~ type_parameter)* ~ ">" }
type_arguments = { type_ ~ ("," ~ type_)* }

// Type definition
type_ = { 
    sized_type |
    core_type |
    matrix_type |
    array_type |
    pairs_type |
    generic_type |
    type_parameter |
    identifier
}

// Indentation-based blocks
INDENT = _{ "\t" }
NEWLINE = _{ "\n" | "\r\n" }
empty_line = _{ INDENT* ~ NEWLINE }
indented_block = { NEWLINE ~ (empty_line)* ~ INDENT+ ~ statement ~ (NEWLINE ~ (empty_line)* ~ INDENT+ ~ statement)* }

// Apply-blocks (core language feature)
apply_block = { identifier ~ ":" ~ indented_block }

// Setup blocks for functions
description_block = { "description" ~ string }
input_type = { 
    sized_type |
    core_type |
    matrix_type |
    array_type |
    pairs_type |
    generic_type |
    type_parameter
}
input_declaration = { input_type ~ identifier }
input_block = { "input" ~ indented_input_block }
indented_input_block = { NEWLINE ~ (empty_line)* ~ INDENT+ ~ input_declaration ~ (NEWLINE ~ (empty_line)* ~ INDENT+ ~ input_declaration)* }
indented_block_with_declarations = { NEWLINE ~ INDENT+ ~ input_declaration ~ (NEWLINE ~ INDENT+ ~ input_declaration)* }

setup_block = { (description_block ~ NEWLINE ~ input_block) | (input_block ~ NEWLINE ~ description_block) | input_block | description_block }

// Object access and method calls
function_call = { identifier ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }
method_call_base = { identifier | "(" ~ expression ~ ")" }
method_call_segment = { "." ~ (identifier ~ ("(" ~ (expression ~ ("," ~ expression)*)? ~ ")")? | identifier) }
method_call = { method_call_base ~ method_call_segment+ }
property_access = { identifier ~ ("." ~ identifier)+ }
array_access = { identifier ~ "[" ~ expression ~ "]" }

// Primary expressions
primary = { 
    number |
    boolean |
    string |
    matrix_literal |
    array_literal |
    array_access |
    method_call |
    function_call |
    property_access |
    identifier |
    "(" ~ expression ~ ")"
}

// Error handling with onError
on_error_expr = { base_expression ~ "onError" ~ base_expression }

// Expression with operator precedence (updated per specification)
base_expression = { primary ~ (operator ~ primary)* }
expression = { on_error_expr | base_expression }

// Operators (removed matrix @ operators as they're now type-based)
operator = _{ binary_op | comparison_op }
binary_op = { "+" | "-" | "*" | "/" | "%" | "^" | "and" | "or" }
comparison_op = { "==" | "!=" | "<" | "<=" | ">" | ">=" | "is" | "not" }

// Arrays and Matrices
array_literal = { "[" ~ (expression ~ ("," ~ expression)*)? ~ "]" }
matrix_row = { "[" ~ (expression ~ ("," ~ expression)*)? ~ "]" }
matrix_literal = { "[" ~ matrix_row ~ ("," ~ matrix_row)* ~ "]" }

// Statements
statement = {
    return_stmt |
    print_stmt |
    println_stmt |
    error_stmt |
    if_stmt |
    iterate_stmt |
    range_iterate_stmt |
    test |
    variable_decl |
    apply_block |
    assignment |
    expression
}

// Type-first variable declarations (no let keyword)
variable_decl = { type_ ~ identifier ~ ("=" ~ expression)? }

// Apply-block style declarations for multiple variables
variable_apply_block = { type_ ~ ":" ~ indented_block_with_assignments }
indented_block_with_assignments = { NEWLINE ~ INDENT+ ~ variable_assignment ~ (NEWLINE ~ INDENT+ ~ variable_assignment)* }
variable_assignment = { identifier ~ ("=" ~ expression)? }

// Constants
constant_block = { "constant" ~ ":" ~ indented_block_with_constant_assignments }
constant_assignment = { type_ ~ identifier ~ "=" ~ expression }
indented_block_with_constant_assignments = { NEWLINE ~ INDENT+ ~ constant_assignment ~ (NEWLINE ~ INDENT+ ~ constant_assignment)* }

// Assignment
assignment = { identifier ~ "=" ~ expression }

// Print statements (both simple and block syntax)
print_stmt = { "print" ~ ((":" ~ indented_print_block) | ("(" ~ expression ~ ")" | expression)) }
println_stmt = { "println" ~ ((":" ~ indented_print_block) | ("(" ~ expression ~ ")" | expression)) }

// Print block for multiple values
indented_print_block = { NEWLINE ~ (empty_line)* ~ INDENT+ ~ print_item ~ (NEWLINE ~ (empty_line)* ~ INDENT+ ~ print_item)* }
print_item = { expression }

// Error statement (function call syntax)
error_stmt = { "error" ~ "(" ~ expression ~ ")" }

// Control flow with indentation
if_stmt = { "if" ~ expression ~ indented_block ~ ("else" ~ indented_block)? }

// Iteration
iterate_stmt = { "iterate" ~ identifier ~ "in" ~ expression ~ indented_block }
range_iterate_stmt = { "iterate" ~ identifier ~ "in" ~ expression ~ "to" ~ expression ~ ("step" ~ expression)? ~ indented_block }

// Test
test = { "test" ~ string ~ indented_block }

// Return
return_stmt = { "return" ~ expression? }

// Function declarations - Only functions block syntax supported

// Functions block (the only supported syntax for function declarations)
functions_block = { "functions" ~ ":" ~ indented_functions_block }
indented_functions_block = { NEWLINE ~ INDENT+ ~ function_in_block ~ (NEWLINE ~ INDENT+ ~ function_in_block)* }
function_in_block = { function_type? ~ identifier ~ "(" ~ ")" ~ function_body }
// Function body statements (similar to indented_block but without initial NEWLINE/INDENT)
function_statements = { statement ~ (NEWLINE ~ (empty_line)* ~ INDENT+ ~ statement)* }

function_body = { (NEWLINE ~ INDENT+ ~ setup_block ~ (empty_line)* ~ INDENT+ ~ function_statements) | (NEWLINE ~ INDENT+ ~ function_statements) }

// Function return type (excludes generic identifiers)
function_type = { 
    sized_type |
    core_type |
    matrix_type |
    array_type |
    pairs_type |
    generic_type |
    type_parameter
}

// Private blocks
private_block = { "private" ~ ":" ~ indented_functions_block }

// Class definition with "is" inheritance
class_field = { type_ ~ identifier }
class_body_item = { class_field | constructor | functions_block }
indented_class_body = { NEWLINE ~ (empty_line)* ~ INDENT+ ~ class_body_item ~ (NEWLINE ~ (empty_line)* ~ INDENT+ ~ class_body_item)* }

class_decl = { 
    "class" ~ identifier ~ type_parameters? ~ 
    ("is" ~ generic_type)? ~ 
    indented_class_body?
}

constructor = { "constructor" ~ "(" ~ constructor_parameter_list? ~ ")" ~ indented_block? }
constructor_parameter_list = { constructor_parameter ~ ("," ~ constructor_parameter)* }
constructor_parameter = { (constructor_type ~ identifier) | identifier }
constructor_type = { 
    sized_type |
    core_type |
    matrix_type |
    array_type |
    pairs_type |
    generic_type
}

// Program with proper newline handling
program_item = { start_function | implicit_start_function | functions_block | class_decl | statement }
program = { SOI ~ NEWLINE* ~ (program_item ~ NEWLINE*)* ~ EOI }

start_function = { "function" ~ "start" ~ "(" ~ ")" ~ indented_block }
implicit_start_function = { "start" ~ "(" ~ ")" ~ indented_block } 