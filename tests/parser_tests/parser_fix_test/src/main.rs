use pest::Parser;
use pest::iterators::Pair;
use pest_derive::Parser;
use std::fmt;

// Define error structs for testing
#[derive(Debug, Clone)]
struct SourceLocation {
    start: usize,
    end: usize,
}

#[derive(Debug, Clone)]
struct ErrorContext {
    message: String,
    location: Option<SourceLocation>,
    help: Option<String>,
}

impl ErrorContext {
    fn new(message: impl Into<String>) -> Self {
        Self {
            message: message.into(),
            location: None,
            help: None,
        }
    }

    fn with_location_option(mut self, location: Option<SourceLocation>) -> Self {
        if let Some(loc) = location {
            self.location = Some(loc);
        }
        self
    }

    fn with_help_option(mut self, help: Option<String>) -> Self {
        if let Some(h) = help {
            self.help = Some(h);
        }
        self
    }
}

#[derive(Debug)]
enum CompilerError {
    ParseError(ErrorContext),
}

impl CompilerError {
    fn parse_error(message: String, location: Option<SourceLocation>, help: Option<String>) -> Self {
        CompilerError::ParseError(
            ErrorContext::new(message)
                .with_location_option(location)
                .with_help_option(help)
        )
    }
}

// Define our own CleanParser for testing purposes
#[derive(Parser)]
#[grammar = "../../src/parser/grammar.pest"] // Adjust the path to the grammar file
pub struct CleanParser;

// The Rule enum is automatically generated by the pest_derive macro
// We don't need to re-export it, we just need to make it public
// So the fix for the main Clean Language parser is to just make the
// automatically generated Rule enum public by attaching 'pub' to the CleanParser struct

fn main() {
    println!("Starting parser fix test with error handling...");
    
    // Simple source code to parse
    let source = r#"
        start() {
            let x: integer = 10;
            print x;
        }
    "#;
    
    // Parse the program
    match CleanParser::parse(Rule::program, source) {
        Ok(pairs) => {
            println!("Successfully parsed the program!");
            // Iterate through the parse tree
            for pair in pairs {
                print_pair(pair, 0);
            }
        }
        Err(e) => {
            // Test our error handling
            let error = CompilerError::parse_error(
                e.to_string(),
                Some(SourceLocation { start: 0, end: 0 }),
                Some("Check your syntax".to_string())
            );
            println!("Error: {:?}", error);
            std::process::exit(1);
        }
    }
    
    println!("Parser test completed successfully!");
    println!("Fix implementation notes:");
    println!("1. The pest_derive macro automatically generates the Rule enum");
    println!("2. We don't need to use 'pub use self::Rule'");
    println!("3. We can reference Rule directly since it's already in scope");
    println!("4. Our error handling is now consistent across the codebase");
}

// Helper function to print the parse tree
fn print_pair(pair: Pair<Rule>, indent: usize) {
    let indent_str = " ".repeat(indent);
    println!("{}Rule::{:?} => {}", indent_str, pair.as_rule(), pair.as_str());
    
    // Print inner pairs
    for inner_pair in pair.into_inner() {
        print_pair(inner_pair, indent + 2);
    }
} 