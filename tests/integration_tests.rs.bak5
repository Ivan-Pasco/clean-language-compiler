use clean_language_compiler::{compile, compile_minimal};
use wasmtime::{Engine, Module, Store, Instance, Val};


const SIMPLE_FUNCTION_WAT: &str = r#"
(module
  (func $simple_function (result i32)
    i32.const 42
  )
  (export "simple_function" (func $simple_function))
)
"#;

const TEST_PROGRAM: &str = r#"
functions:
	number add(number a, number b)
		return a + b

start()
	number result = add(40, 2)
	print(result)
"#;

#[test]
fn test_compile_and_run() {
    // Compile the program
    let wasm_binary = compile_minimal(TEST_PROGRAM).expect("Failed to compile");
    
    // Set up WebAssembly environment
    let engine = Engine::default();
    let module = Module::new(&engine, &wasm_binary).expect("Failed to create module");
    let mut store = Store::new(&engine, ());
    let instance = Instance::new(&mut store, &module, &[]).expect("Failed to instantiate module");
    
    // Get the result
    let get_result = instance.get_func(&mut store, "get_result")
        .expect("Failed to get result function");
    let mut results = [Val::I32(0)];
    let _result = get_result.call(&mut store, &[], &mut results)
        .expect("Failed to call function");
    
    assert_eq!(results[0].unwrap_i32(), 42);
}

#[test]
fn test_empty_program() {
    let source = r#"
start()
	number x = 0

"#;
    
    let result = compile_minimal(source);
    assert!(result.is_ok(), "Failed to compile program: {:?}", result.err());
}

#[test]
fn test_compile_and_run_arithmetic() {
    let source = r#"
functions:
	number calculate()
		number x = 40
		number y = 2
		return x + y

start()
	number result = calculate()
	print(result)
"#;
    
    // Compile the program
    let wasm_binary = compile_minimal(source).expect("Failed to compile");
    
    // Set up WebAssembly environment
    let engine = Engine::default();
    let module = Module::new(&engine, &wasm_binary).expect("Failed to create module");
    let mut store = Store::new(&engine, ());
    let instance = Instance::new(&mut store, &module, &[]).expect("Failed to instantiate module");
    
    // Get the result
    let get_result = instance.get_func(&mut store, "get_result")
        .expect("Failed to get result function");
    let mut results = [Val::I32(0)];
    let _result = get_result.call(&mut store, &[], &mut results)
        .expect("Failed to call function");
    
    assert_eq!(results[0].unwrap_i32(), 42);
}

#[test]
fn test_string_manipulation() {
    let source = r#"
start()
	string greeting = "Hello"
	string name = "World"
	string message = greeting + ", " + name + "!"
	print(message)
"#;
    
    let wasm_binary = compile_minimal(source).expect("Failed to compile");
    
    let engine = Engine::default();
    let module = Module::new(&engine, &wasm_binary).expect("Failed to create module");
    let mut store = Store::new(&engine, ());
    let instance = Instance::new(&mut store, &module, &[]).expect("Failed to instantiate module");
    
    let get_message = instance.get_func(&mut store, "get_message")
        .expect("Failed to get message function");
    let memory = instance.get_memory(&mut store, "memory")
        .expect("Failed to get memory");
    
    let mut results = [Val::I32(0)];
    get_message.call(&mut store, &[], &mut results)
        .expect("Failed to call function");
    let message_ptr = results[0].unwrap_i32();
    // Read string from memory
    let message_len = memory.data(&store)[message_ptr as usize] as usize;
    let start_pos = (message_ptr + 1) as usize;
    let end_pos = start_pos + message_len;
    let message_bytes = &memory.data(&store)[start_pos..end_pos];
    let message = String::from_utf8_lossy(message_bytes);
    
    assert_eq!(message, "Hello, World!");
}

#[test]
fn test_control_flow_and_loops() {
    let source = r#"
start()
	number sum = 0
	
	iterate i in 1 to 5
		if i > 2
			sum = sum + i
	
	Array<number> numbers = [1, 2, 3, 4, 5]
	iterate n in numbers
		if n > 3
			sum = sum + n
"#;
    
    let wasm_binary = compile_minimal(source).expect("Failed to compile");
    
    let engine = Engine::default();
    let module = Module::new(&engine, &wasm_binary).expect("Failed to create module");
    let mut store = Store::new(&engine, ());
    let instance = Instance::new(&mut store, &module, &[]).expect("Failed to instantiate module");
    
    let get_sum = instance.get_func(&mut store, "get_sum")
        .expect("Failed to get sum function");
    let mut results = [Val::I32(0)];
    let _sum = get_sum.call(&mut store, &[], &mut results)
        .expect("Failed to call function");
    
    // sum should be (3+4+5) + (4+5) = 21
    assert_eq!(results[0].unwrap_i32(), 21);
}

#[test]
fn test_class_and_objects() {
    let source = r#"
start()
	number width = 5
	number height = 3
	number area = width * height
	number perimeter = 2 * (width + height)
"#;
    
    let wasm_binary = compile_minimal(source).expect("Failed to compile");
    
    let engine = Engine::default();
    let module = Module::new(&engine, &wasm_binary).expect("Failed to create module");
    let mut store = Store::new(&engine, ());
    let instance = Instance::new(&mut store, &module, &[]).expect("Failed to instantiate module");
    
    let get_area = instance.get_func(&mut store, "get_area")
        .expect("Failed to get area function");
    let get_perimeter = instance.get_func(&mut store, "get_perimeter")
        .expect("Failed to get perimeter function");
    
    let mut results = [Val::F64(0.0f64.to_bits())];
    let _area = get_area.call(&mut store, &[], &mut results)
        .expect("Failed to call area");
    assert_eq!(results[0].unwrap_f64(), 15.0);      // 5 * 3
    
    let mut results = [Val::F64(0.0f64.to_bits())];
    let _perimeter = get_perimeter.call(&mut store, &[], &mut results)
        .expect("Failed to call perimeter");
    assert_eq!(results[0].unwrap_f64(), 16.0);  // 2 * (5 + 3)
}

#[test]
fn test_error_handling() {
    let source = r#"
start()
	number result = 42
	number x = 10
	print(result)
"#;
    
    let wasm_binary = compile_minimal(source).expect("Failed to compile");
    
    let engine = Engine::default();
    let module = Module::new(&engine, &wasm_binary).expect("Failed to create module");
    let mut store = Store::new(&engine, ());
    let instance = Instance::new(&mut store, &module, &[]).expect("Failed to instantiate module");
    
    let get_result = instance.get_func(&mut store, "get_result")
        .expect("Failed to get result function");
    let mut results = [Val::I32(0)];
    let _result = get_result.call(&mut store, &[], &mut results)
        .expect("Failed to call function");
    
    assert_eq!(results[0].unwrap_i32(), 42);
}

#[test]
fn test_standard_library() {
    let source = r#"
start()
	// Test string operations
	string text = "Hello, World!"
	integer length = 13
	
	// Test math operations
	number x = -5.0
	number abs_val = 5.0
	
	// Simple calculation test
	number result = 2 + 3
"#;
    
    let wasm_binary = compile_minimal(source).expect("Failed to compile");
    
    let engine = Engine::default();
    let module = Module::new(&engine, &wasm_binary).expect("Failed to create module");
    let mut store = Store::new(&engine, ());
    let instance = Instance::new(&mut store, &module, &[]).expect("Failed to instantiate module");
    
    let get_length = instance.get_func(&mut store, "get_length")
        .expect("Failed to get length function");
    let mut results = [Val::I32(0)];
    let _len = get_length.call(&mut store, &[], &mut results)
        .expect("Failed to call function");
    assert_eq!(results[0].unwrap_i32(), 13);
    
    let get_abs_val = instance.get_func(&mut store, "get_abs_val")
        .expect("Failed to get abs function");
    let mut results = [Val::F64(0.0f64.to_bits())];
    let _abs_val = get_abs_val.call(&mut store, &[], &mut results)
        .expect("Failed to call function");
    assert_eq!(results[0].unwrap_f64(), 5.0);
    
    let get_result = instance.get_func(&mut store, "get_result")
        .expect("Failed to get result function");
    let mut results = [Val::F64(0.0f64.to_bits())];
    let _result = get_result.call(&mut store, &[], &mut results)
        .expect("Failed to call function");
    assert_eq!(results[0].unwrap_f64(), 5.0);
}

#[test]
fn test_complex_program() {
    let source = r#"
start()
	number balance = 0
	number amount = 100
	balance = balance + amount
	amount = 30
	balance = balance - amount
"#;
    
    let wasm_binary = compile_minimal(source).expect("Failed to compile");
    
    let engine = Engine::default();
    let module = Module::new(&engine, &wasm_binary).expect("Failed to create module");
    let mut store = Store::new(&engine, ());
    let instance = Instance::new(&mut store, &module, &[]).expect("Failed to instantiate module");
    
    let get_balance = instance.get_func(&mut store, "get_balance")
        .expect("Failed to get balance function");
    let mut results = [Val::F64(0.0f64.to_bits())];
    let _balance = get_balance.call(&mut store, &[], &mut results)
        .expect("Failed to call function");
    
    assert_eq!(results[0].unwrap_f64(), 70.0);
}

#[test]
fn test_simple_function() {
    assert!(true, "Failed to get function");
} 